/*
 * abtool_stubs.c - Notify and event callback function stubs.
 * This file was generated by `gxv' from `abtool.G'.
 */

#include <stdio.h>
#include <sys/types.h>
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/textsw.h>
#include <xview/dragdrop.h>
#include <gdd.h>
#include "abtool_ui.h"

void	keypress(Xv_window, Event *, Notify_arg, Notify_event_type);
void	abtool_initialize();

/*
 * Global object definitions.
 */
abtool_win_objects	*Abtool_win;
abtool_pwin_objects	*Abtool_pwin;

/*
 * Instance XV_KEY_DATA key.  An instance is a set of related
 * user interface objects.  A pointer to an object's instance
 * is stored under this key in every object.  This must be a
 * global variable.
 */
Attr_attribute	INSTANCE;

main(int argc, char **argv)
{
	/*
	 * Initialize XView.
	 */
	xv_init(XV_INIT_ARGC_PTR_ARGV, &argc, argv, NULL);
	INSTANCE = xv_unique_key();
	
	/*
	 * Initialize user interface components.
	 * Do NOT edit the object initializations by hand.
	 */
	Abtool_win = abtool_win_objects_initialize(NULL, NULL);
	Abtool_pwin = abtool_pwin_objects_initialize(NULL, Abtool_win->win);
	abtool_initialize(argc, argv);

	/*
	 * Initialize the Drag Drop package.
	 */
	gdd_init_dragdrop(Abtool_win->win);

	/*
	 * Turn control over to XView.
	 */
	xv_main_loop(Abtool_win->win);
	exit(0);
}

/*
 * Menu handler for `filenames_menu'.
 */
Menu
ab_filenames(Menu menu, Menu_generate op)
{
	int i, j;
	Menu_item item;

	abtool_win_objects * ip = (abtool_win_objects *) xv_get(menu, XV_KEY_DATA, INSTANCE);

	switch (op) {
	case MENU_DISPLAY:
		i = FALSE;
		if (list_seln() < 0) i = TRUE;
		for (j=1; j<=(int)xv_get(menu, MENU_NITEMS); j++) {
		    item = (Menu_item)xv_get(menu, MENU_NTH_ITEM, j);
		    xv_set(item, MENU_INACTIVE, i, NULL);
		}
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:		
		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return menu;
}

/*
 * Notify callback function for `audio_button'.
 */
void
ab_audio(Panel_item item, Event *event)
{
	static int pid = 0;
	int n;
	char *cmd;

	if (pid > 0 && kill(pid, 0) >= 0) {
	   fprintf(stderr, "Audio control already running: pid %d\n", pid);
	   return;
	}
	cmd = (char *)xv_get(Abtool_pwin->audio_cmd, PANEL_VALUE);
	if ((pid = fork()) < 0)
	   perror("vfork");
	else if (pid == 0) {
	   if (execlp(cmd, cmd, (char *)0) < 0) perror("exec");
	   _exit(-1);
	}
}

/*
 * Notify callback function for `props_button'.
 */
void
abtool_win_props_button_notify_callback(Panel_item item, Event *event)
{
	abtool_win_objects *ip = (abtool_win_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);

	xv_set(Abtool_pwin->pwin,	/* Offsets work around XView bugs */ 
	    XV_X, xv_get(Abtool_win->win, XV_X) - 5,
	    XV_Y, xv_get(Abtool_win->win, XV_Y)
                + xv_get(Abtool_win->win, XV_HEIGHT) + 24, NULL);

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Abtool_pwin->pwin, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
	xv_set(Abtool_pwin->pwin, XV_SHOW, TRUE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Drop callback function for `drop_target1'.
 */
void
canvas_drop_function(Xv_opaque item, Event *event, GDD_DROP_INFO *drop_info)
{
	abtool_win_objects *ip = (abtool_win_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	fputs("abtool: canvas_drop_function\n", stderr);
	fputs("Successful Drop. GDD_DROP_INFO contents:\n", stderr);
	gdd_print_drop_info(drop_info);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}

/*
 * Drag callback function for `drop_target1'.
 */
void
ab_drag_function(Xv_opaque item, Event *event, GDD_DROP_INFO *drop_info, int drag_state)
{
	abtool_win_objects *ip = (abtool_win_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (drag_state) {
	case GDD_DRAG_STARTED:
		break;

	case GDD_DRAG_COMPLETED:
		break;

	}
	fputs("abtool: ab_drag_function\n", stderr);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}

/*
 * Notify callback function for `quit_button'.
 */
void
ab_quit(Panel_item item, Event *event)
{
	xv_destroy_safe(Abtool_win->win);
}

/*
 * Notify callback function for `play_button'.
 */
void
ab_play(Panel_item item, Event *event)
{
	char *label = (char *)xv_get(item, PANEL_LABEL_STRING);

	if (label[0] == 'P') {
	    start_play(-1);		/* Initialize A/B list, start playing */
	} else {
	    stop_play();		/* Stop whatever is playing */
	}
}

/*
 * Notify callback function for `list1'.
 */
int
flist(Panel_item item, char *string, Xv_opaque client_data, Panel_list_op op, Event *event, int row)
{
	switch(op) {
	case PANEL_LIST_OP_DESELECT:
	    set_align(row);
	    break;

	case PANEL_LIST_OP_SELECT:
	    show_align(row);
	    break;

	case PANEL_LIST_OP_VALIDATE:
	    break;

	case PANEL_LIST_OP_DELETE:
	    break;
	}
	return XV_OK;
}

/*
 * Event callback function for `canvas1'.
 */
Notify_value
abtool_win_canvas1_event_callback(Xv_window win, Event *event, Notify_arg arg, Notify_event_type type)
{
/*	fprintf(stderr,"abtool: canvas1: event %d\n", event_id(event));	*/

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	if (event_is_ascii(event) && event_is_down(event))
	{
		keypress(win, event, arg, type);
	}
	
	/* gxv_end_connections */

	return notify_next_event_func(win, (Notify_event) event, arg, type);
}

/*
 * Notify callback for keypresses not grabbed by panel items.
 */
void
keypress(Xv_window win, Event *event, Notify_arg arg, Notify_event_type type)
{
	start_play(event_id(event));	/* Play a single segment from 1 file */
}

/*
 * Notify callback function for `fname'.
 */
void
showfiles(Panel_item item, int value, Event *event)
{
	show_file(-1);	/* Update file list with names shown or hidden */
}

/*
 * Notify callback function for `audio_hold'.
 */
void
audio_hold(Panel_item item, int value, Event *event)
{
	if (xv_get(Abtool_pwin->audio_hold, PANEL_VALUE)) abp_close_device();
}
